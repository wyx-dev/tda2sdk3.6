/******************************************************************************
*
* Copyright (C) 2018-2019 Momenta Incorporated - https://www.momenta.ai/
*
* ALL RIGHTS RESERVED
*
******************************************************************************/

/*******************************************************************************
 *  INCLUDE FILES
 *******************************************************************************
 */
#include <src/hlos/common/chains_common.h>
#include "hal_modl_common.h"

/******************************************************************************
 *  MODL Common functions:
 *      The following functions should be in sync with the similar functions
 *      defined in the $(tidl_PATH)\modules\ti_dl\test\src\tidl_tb.c file.
 *          hal_modl_ReadNet <-> tidl_readNet
 *          hal_modl_AllocNetParamsMem <-> tidl_allocNetParamsMem
 *          hal_modl_FillNetParamsMem <-> tidl_fillNetParamsMem
 *          hal_modl_FreeNetParamsMem <-> tidl_freeNetParamsMem
 ******************************************************************************/

/**
 *******************************************************************************
 *
 * \brief   This function read the Network Model BIN file
 *          generated by Import tool.
 *
 * \return  SYSTEM_LINK_STATUS_SOK on success
 *******************************************************************************
*/
Int32 hal_modl_ReadNet(sTIDL_Network_t *net, char *netFile)
{
    Int32 fp;
    UInt32 readSize;

    fp = ChainsCommon_Osal_fileOpen(
                            netFile,
                            CHAINSCOMMON_OSAL_FILEMODE_READ_BIN);
    UTILS_assert(-1 != fp);

    ChainsCommon_Osal_fileRead(
                            fp,
                            (UInt8*)net,
                            sizeof(sTIDL_Network_t),
                            &readSize);
    UTILS_assert(readSize == sizeof(sTIDL_Network_t));

    ChainsCommon_Osal_fileClose(fp);

    return SYSTEM_LINK_STATUS_SOK;
}

/**
 *******************************************************************************
 *
 * \brief   This function alloc the sTIDL_Network_t memory.
 *
 * \return  SYSTEM_LINK_STATUS_SOK on success
 *******************************************************************************
*/
Int32 hal_modl_AllocNetParamsMem(sTIDL_Network_t *net)
{
    Int32 i;

    for(i = 0; i < net->numLayers; i++)
    {
        if((TIDL_ConvolutionLayer == net->TIDLLayers[i].layerType) ||
           (TIDL_Deconv2DLayer == net->TIDLLayers[i].layerType))
        {
            sTIDL_ConvParams_t *conv2dPrms = \
                                            &net->TIDLLayers[i].layerParams.convParams;
            conv2dPrms->weights.bufSize = \
                net->weightsElementSize * (conv2dPrms->kernelW * conv2dPrms->kernelH *
                conv2dPrms->numInChannels * conv2dPrms->numOutChannels)
                /conv2dPrms->numGroups;
            conv2dPrms->weights.ptr = \
                ChainsCommon_Osal_memAlloc(conv2dPrms->weights.bufSize, 32);

            conv2dPrms->bias.bufSize = net->biasElementSize * conv2dPrms->numOutChannels;
            conv2dPrms->bias.ptr = \
                ChainsCommon_Osal_memAlloc(conv2dPrms->bias.bufSize, 32);
        }
        else if(TIDL_BiasLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_BiasParams_t *biasPrms = &net->TIDLLayers[i].layerParams.biasParams;
            biasPrms->bias.bufSize = net->biasElementSize * biasPrms->numChannels;
            biasPrms->bias.ptr = \
                ChainsCommon_Osal_memAlloc(biasPrms->bias.bufSize, 32);
        }
        else if(TIDL_BatchNormLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_BatchNormParams_t *batchNormPrms = \
                &net->TIDLLayers[i].layerParams.batchNormParams;
            batchNormPrms->weights.bufSize = \
                net->weightsElementSize * batchNormPrms->numChannels;
            batchNormPrms->weights.ptr =
                ChainsCommon_Osal_memAlloc(batchNormPrms->weights.bufSize, 32);

            batchNormPrms->bias.bufSize = \
                net->biasElementSize * batchNormPrms->numChannels;
            batchNormPrms->bias.ptr =
                ChainsCommon_Osal_memAlloc(batchNormPrms->bias.bufSize, 32);

            batchNormPrms->reluParams.slope.bufSize =
                net->slopeElementSize * batchNormPrms->numChannels;
            if(TIDL_PRelU == batchNormPrms->reluParams.reluType)
            {
                batchNormPrms->reluParams.slope.ptr = \
                    ChainsCommon_Osal_memAlloc(
                            batchNormPrms->reluParams.slope.bufSize, 32);
            }
        }
        else if(TIDL_InnerProductLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_InnerProductParams_t *ipPrms = \
                                    &net->TIDLLayers[i].layerParams.innerProductParams;
            ipPrms->bias.bufSize = net->biasElementSize * ipPrms->numOutNodes;
            ipPrms->bias.ptr = \
                ChainsCommon_Osal_memAlloc(
                    SystemUtils_align(ipPrms->bias.bufSize, 128), 32);

            ipPrms->weights.bufSize = \
                net->weightsElementSize* ipPrms->numInNodes * ipPrms->numOutNodes;
            ipPrms->weights.ptr = \
                ChainsCommon_Osal_memAlloc(
                    SystemUtils_align((ipPrms->weights.bufSize + 16 * \
                        net->TIDLLayers[i].layerParams.innerProductParams.numInNodes),
                            1024), 32);
        }
        else if(TIDL_DetectionOutputLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_DetectOutputParams_t *detectPrms = \
                            &net->TIDLLayers[i].layerParams.detectOutParams;
            detectPrms->priorBox.bufSize = detectPrms->priorBoxSize * sizeof(float);
            detectPrms->priorBox.ptr = \
                ChainsCommon_Osal_memAlloc(detectPrms->priorBox.bufSize, 32);
        }
    }

    return SYSTEM_LINK_STATUS_SOK;
}

/**
 *******************************************************************************
 *
 * \brief   This function fill the sTIDL_Network_t memory.
 *
 * \return  SYSTEM_LINK_STATUS_SOK on success
 *******************************************************************************
*/
Int32 hal_modl_FillNetParamsMem(sTIDL_Network_t *net, char *netPrm)
{
    Int32 i = 0;
    UInt32 dataSize = 0;
    char *pNetPrm = NULL;

    if((NULL == net) || (NULL == netPrm))
    {
        return -1;
    }

    pNetPrm = netPrm;

    for(i = 0; i < net->numLayers; i++)
    {
        if((TIDL_ConvolutionLayer == net->TIDLLayers[i].layerType) ||
           (TIDL_Deconv2DLayer == net->TIDLLayers[i].layerType))
        {
            sTIDL_ConvParams_t *conv2dPrms = &net->TIDLLayers[i].layerParams.convParams;

            dataSize = (conv2dPrms->numInChannels * conv2dPrms->numOutChannels *
                conv2dPrms->kernelW * conv2dPrms->kernelH)/conv2dPrms->numGroups;

            /* Read weights based on its size */
            if(net->weightsElementSize == 2)
            {
                memcpy((UInt8*)conv2dPrms->weights.ptr, pNetPrm, (dataSize * 2));
                pNetPrm += (dataSize * 2);
            }
            else
            {
                memcpy((UInt8*)conv2dPrms->weights.ptr, pNetPrm, dataSize);
                pNetPrm += dataSize;
            }

            if(conv2dPrms->enableBias)
            {
                dataSize = conv2dPrms->numOutChannels;
                memcpy((UInt8*)conv2dPrms->bias.ptr, pNetPrm, (dataSize * net->biasElementSize));
                pNetPrm += (dataSize * net->biasElementSize);
            }
            else
            {
                memset(
                    (Int8 *)conv2dPrms->bias.ptr, 0, conv2dPrms->numOutChannels * net->biasElementSize);
            }

            /* Cache Wb of the buffers */
            dataSize = (conv2dPrms->numInChannels * conv2dPrms->numOutChannels *
                    conv2dPrms->kernelW * conv2dPrms->kernelH)/conv2dPrms->numGroups;
            if(net->weightsElementSize == 2)
            {
                dataSize *= 2;
            }
            ChainsCommon_Osal_cacheWb(
                (UInt32)conv2dPrms->weights.ptr,
                dataSize);

            dataSize = conv2dPrms->numOutChannels;
            ChainsCommon_Osal_cacheWb(
                (UInt32)conv2dPrms->bias.ptr,
                (dataSize * net->biasElementSize));
        }
        else if(TIDL_BiasLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_BiasParams_t *biasPrms =&net->TIDLLayers[i].layerParams.biasParams;
            dataSize = biasPrms->numChannels;

            memcpy((UInt8 *)biasPrms->bias.ptr, pNetPrm, (dataSize * net->biasElementSize));
            pNetPrm += (dataSize * net->biasElementSize);
            ChainsCommon_Osal_cacheWb(
                (UInt32)biasPrms->bias.ptr,
                (dataSize * net->biasElementSize));
        }
        else if(TIDL_BatchNormLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_BatchNormParams_t *bNPrms = \
                                &net->TIDLLayers[i].layerParams.batchNormParams;
            dataSize = bNPrms->numChannels;

            if(net->weightsElementSize == 2)
            {
                memcpy((UInt8*)bNPrms->weights.ptr, pNetPrm, (dataSize * 2));
                pNetPrm += (dataSize * 2);
                ChainsCommon_Osal_cacheWb(
                    (UInt32)bNPrms->weights.ptr,
                    (dataSize * 2));
            }
            else
            {
                memcpy((UInt8*)bNPrms->weights.ptr, pNetPrm, dataSize);
                pNetPrm += dataSize;
                ChainsCommon_Osal_cacheWb(
                    (UInt32)bNPrms->weights.ptr,
                    dataSize);
            }

            memcpy((UInt8*)bNPrms->bias.ptr, pNetPrm, (dataSize * net->biasElementSize));
            pNetPrm += (dataSize * net->biasElementSize);
            ChainsCommon_Osal_cacheWb(
                (UInt32)bNPrms->bias.ptr,
                (dataSize * net->biasElementSize));

            if(TIDL_PRelU == bNPrms->reluParams.reluType)
            {
                if(net->slopeElementSize == 2)
                {
                    memcpy((UInt8*)bNPrms->reluParams.slope.ptr, pNetPrm, (dataSize * 2));
                    pNetPrm += (dataSize * 2);
                    ChainsCommon_Osal_cacheWb(
                        (UInt32)bNPrms->reluParams.slope.ptr,
                        (dataSize * 2));
                }
                else
                {
                    memcpy((UInt8*)bNPrms->reluParams.slope.ptr, pNetPrm, dataSize);
                    pNetPrm += dataSize;
                    ChainsCommon_Osal_cacheWb(
                        (UInt32)bNPrms->reluParams.slope.ptr,
                        dataSize);
                }
            }
        }
        else if(TIDL_InnerProductLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_InnerProductParams_t *ipPrms = \
                            &net->TIDLLayers[i].layerParams.innerProductParams;
            dataSize = ipPrms->numInNodes * ipPrms->numOutNodes;

            /* Read weights based on its size */
            if(net->weightsElementSize == 2)
            {
                memcpy((UInt8*)ipPrms->weights.ptr, pNetPrm, (dataSize * 2));
                pNetPrm += (dataSize * 2);
                ChainsCommon_Osal_cacheWb(
                    (UInt32)ipPrms->weights.ptr,
                    (dataSize * 2));
            }
            else
            {
                memcpy((UInt8*)ipPrms->weights.ptr, pNetPrm, dataSize);
                pNetPrm += dataSize;
                ChainsCommon_Osal_cacheWb(
                    (UInt32)ipPrms->weights.ptr,
                    dataSize);
            }

            dataSize = ipPrms->numOutNodes;

            memcpy((UInt8*)ipPrms->bias.ptr, pNetPrm, (dataSize * net->biasElementSize));
            pNetPrm += (dataSize * net->biasElementSize);
            ChainsCommon_Osal_cacheWb(
                (UInt32)ipPrms->bias.ptr,
                (dataSize * net->biasElementSize));
        }
        else if(TIDL_DetectionOutputLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_DetectOutputParams_t *detectPrms = \
                            &net->TIDLLayers[i].layerParams.detectOutParams;
            dataSize = detectPrms->priorBoxSize;

            memcpy((UInt8*)detectPrms->priorBox.ptr, pNetPrm, (dataSize * sizeof(float)));
            pNetPrm += (dataSize * sizeof(float));
            ChainsCommon_Osal_cacheWb(
                (UInt32)detectPrms->priorBox.ptr,
                (dataSize * sizeof(float)));
        }
    }

    /* Cache wb since it is read on EVE and DSP */
    ChainsCommon_Osal_cacheWb(
        (UInt32)net,
        sizeof(sTIDL_Network_t));

    return SYSTEM_LINK_STATUS_SOK;
}

/**
 *******************************************************************************
 *
 * \brief   This function free the sTIDL_Network_t memory.
 *
 * \return  SYSTEM_LINK_STATUS_SOK on success
 *******************************************************************************
*/
Int32 hal_modl_FreeNetParamsMem(sTIDL_Network_t *net)
{
    Int32 i;

    for(i = 0; i < net->numLayers; i++)
    {
        if((TIDL_ConvolutionLayer == net->TIDLLayers[i].layerType) ||
           (TIDL_Deconv2DLayer == net->TIDLLayers[i].layerType))
        {
            sTIDL_ConvParams_t *conv2dPrms = \
                                            &net->TIDLLayers[i].layerParams.convParams;
            conv2dPrms->weights.bufSize = \
                net->weightsElementSize * (conv2dPrms->kernelW * conv2dPrms->kernelH *
                conv2dPrms->numInChannels * conv2dPrms->numOutChannels)
                /conv2dPrms->numGroups;
            ChainsCommon_Osal_memFree(
                                conv2dPrms->weights.ptr, conv2dPrms->weights.bufSize);

            conv2dPrms->bias.bufSize = net->biasElementSize * conv2dPrms->numOutChannels;
            ChainsCommon_Osal_memFree(
                    conv2dPrms->bias.ptr, conv2dPrms->bias.bufSize);
        }
        else if(TIDL_BiasLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_BiasParams_t *biasPrms = &net->TIDLLayers[i].layerParams.biasParams;
            biasPrms->bias.bufSize = net->biasElementSize * biasPrms->numChannels;
            ChainsCommon_Osal_memFree(
                    biasPrms->bias.ptr, biasPrms->bias.bufSize);
        }
        else if(TIDL_BatchNormLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_BatchNormParams_t *batchNormPrms = \
                &net->TIDLLayers[i].layerParams.batchNormParams;
            batchNormPrms->weights.bufSize = \
                net->weightsElementSize * batchNormPrms->numChannels;
            ChainsCommon_Osal_memFree(
                    batchNormPrms->weights.ptr, batchNormPrms->weights.bufSize);

            batchNormPrms->bias.bufSize = \
                net->biasElementSize * batchNormPrms->numChannels;
            ChainsCommon_Osal_memFree(
                    batchNormPrms->bias.ptr, batchNormPrms->bias.bufSize);

            batchNormPrms->reluParams.slope.bufSize =
                net->slopeElementSize * batchNormPrms->numChannels;
            if(TIDL_PRelU == batchNormPrms->reluParams.reluType)
            {
                ChainsCommon_Osal_memFree(
                        batchNormPrms->reluParams.slope.ptr,
                        batchNormPrms->reluParams.slope.bufSize);
            }
        }
        else if(TIDL_InnerProductLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_InnerProductParams_t *ipPrms = \
                                    &net->TIDLLayers[i].layerParams.innerProductParams;
            ipPrms->bias.bufSize = net->biasElementSize * ipPrms->numOutNodes;
            ChainsCommon_Osal_memFree(
                    ipPrms->bias.ptr, SystemUtils_align(ipPrms->bias.bufSize, 128));


            ipPrms->weights.bufSize = \
                net->weightsElementSize* ipPrms->numInNodes * ipPrms->numOutNodes;
            ChainsCommon_Osal_memFree(
                    ipPrms->weights.ptr,
                    SystemUtils_align((ipPrms->weights.bufSize + 16 * \
                        net->TIDLLayers[i].layerParams.innerProductParams.numInNodes),
                            1024));
        }
        else if(TIDL_DetectionOutputLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_DetectOutputParams_t *detectPrms = \
                            &net->TIDLLayers[i].layerParams.detectOutParams;
            detectPrms->priorBox.bufSize = detectPrms->priorBoxSize * sizeof(float);
            ChainsCommon_Osal_memFree(
                    detectPrms->priorBox.ptr, detectPrms->priorBox.bufSize);
        }
    }

    return SYSTEM_LINK_STATUS_SOK;
}

/**
 *******************************************************************************
 *
 * \brief   This function convert sTIDL_Network_t
 *          physical addresses to virtual addresses.
 *
 * \return  SYSTEM_LINK_STATUS_SOK on success
 *******************************************************************************
*/
Int32 hal_modl_NetParamsMemPhys2Virt(sTIDL_Network_t *net)
{
    Int32 i;

    for(i = 0; i < net->numLayers; i++)
    {
        if((TIDL_ConvolutionLayer == net->TIDLLayers[i].layerType) ||
           (TIDL_Deconv2DLayer == net->TIDLLayers[i].layerType))
        {
            sTIDL_ConvParams_t *conv2dPrms = \
                                            &net->TIDLLayers[i].layerParams.convParams;

            conv2dPrms->weights.ptr = \
                (void*)ChainsCommon_Osal_getVirtAddr((UInt32)conv2dPrms->weights.ptr);

            conv2dPrms->bias.ptr = \
                (void*)ChainsCommon_Osal_getVirtAddr((UInt32)conv2dPrms->bias.ptr);
        }
        else if(TIDL_BiasLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_BiasParams_t *biasPrms = &net->TIDLLayers[i].layerParams.biasParams;

            biasPrms->bias.ptr = \
                (void*)ChainsCommon_Osal_getVirtAddr((UInt32)biasPrms->bias.ptr);
        }
        else if(TIDL_BatchNormLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_BatchNormParams_t *batchNormPrms = \
                &net->TIDLLayers[i].layerParams.batchNormParams;

            batchNormPrms->weights.ptr =
                (void*)ChainsCommon_Osal_getVirtAddr((UInt32)batchNormPrms->weights.ptr);

            batchNormPrms->bias.ptr =
                (void*)ChainsCommon_Osal_getVirtAddr((UInt32)batchNormPrms->bias.ptr);

            if(TIDL_PRelU == batchNormPrms->reluParams.reluType)
            {
                batchNormPrms->reluParams.slope.ptr = \
                    (void*)ChainsCommon_Osal_getVirtAddr((UInt32)batchNormPrms->reluParams.slope.ptr);
            }
        }
        else if(TIDL_InnerProductLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_InnerProductParams_t *ipPrms = \
                                    &net->TIDLLayers[i].layerParams.innerProductParams;

            ipPrms->bias.ptr = \
                (void*)ChainsCommon_Osal_getVirtAddr((UInt32)ipPrms->bias.ptr);

            ipPrms->weights.ptr = \
                (void*)ChainsCommon_Osal_getVirtAddr((UInt32)ipPrms->weights.ptr);
        }
        else if(TIDL_DetectionOutputLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_DetectOutputParams_t *detectPrms = \
                            &net->TIDLLayers[i].layerParams.detectOutParams;

            detectPrms->priorBox.ptr = \
                (void*)ChainsCommon_Osal_getVirtAddr((UInt32)detectPrms->priorBox.ptr);
        }
    }

    return SYSTEM_LINK_STATUS_SOK;
}

/**
 *******************************************************************************
 *
 * \brief   This function convert sTIDL_Network_t
 *          virtual addresses to physical addresses.
 *
 * \return  SYSTEM_LINK_STATUS_SOK on success
 *******************************************************************************
*/
Int32 hal_modl_NetParamsMemVirt2Phys(sTIDL_Network_t *net)
{
    Int32 i;

    for(i = 0; i < net->numLayers; i++)
    {
        if((TIDL_ConvolutionLayer == net->TIDLLayers[i].layerType) ||
           (TIDL_Deconv2DLayer == net->TIDLLayers[i].layerType))
        {
            sTIDL_ConvParams_t *conv2dPrms = \
                                            &net->TIDLLayers[i].layerParams.convParams;

            conv2dPrms->weights.ptr = \
                (void*)ChainsCommon_Osal_getPhysAddr((UInt32)conv2dPrms->weights.ptr);

            conv2dPrms->bias.ptr = \
                (void*)ChainsCommon_Osal_getPhysAddr((UInt32)conv2dPrms->bias.ptr);
        }
        else if(TIDL_BiasLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_BiasParams_t *biasPrms = &net->TIDLLayers[i].layerParams.biasParams;

            biasPrms->bias.ptr = \
                (void*)ChainsCommon_Osal_getPhysAddr((UInt32)biasPrms->bias.ptr);
        }
        else if(TIDL_BatchNormLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_BatchNormParams_t *batchNormPrms = \
                &net->TIDLLayers[i].layerParams.batchNormParams;

            batchNormPrms->weights.ptr =
                (void*)ChainsCommon_Osal_getPhysAddr((UInt32)batchNormPrms->weights.ptr);

            batchNormPrms->bias.ptr =
                (void*)ChainsCommon_Osal_getPhysAddr((UInt32)batchNormPrms->bias.ptr);

            if(TIDL_PRelU == batchNormPrms->reluParams.reluType)
            {
                batchNormPrms->reluParams.slope.ptr = \
                    (void*)ChainsCommon_Osal_getPhysAddr((UInt32)batchNormPrms->reluParams.slope.ptr);
            }
        }
        else if(TIDL_InnerProductLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_InnerProductParams_t *ipPrms = \
                                    &net->TIDLLayers[i].layerParams.innerProductParams;

            ipPrms->bias.ptr = \
                (void*)ChainsCommon_Osal_getPhysAddr((UInt32)ipPrms->bias.ptr);

            ipPrms->weights.ptr = \
                (void*)ChainsCommon_Osal_getPhysAddr((UInt32)ipPrms->weights.ptr);
        }
        else if(TIDL_DetectionOutputLayer == net->TIDLLayers[i].layerType)
        {
            sTIDL_DetectOutputParams_t *detectPrms = \
                            &net->TIDLLayers[i].layerParams.detectOutParams;

            detectPrms->priorBox.ptr = \
                (void*)ChainsCommon_Osal_getPhysAddr((UInt32)detectPrms->priorBox.ptr);
        }
    }

    return SYSTEM_LINK_STATUS_SOK;
}
